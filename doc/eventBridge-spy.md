# EventBridge Spy

EventBridge Spies work similarely to [Jest Function Spies](https://jestjs.io/docs/mock-function-api). They let you spy on a specific EventBridge bus to test if events have been placed into the specified bus.

## How it works

Under the hood, EventBridge spies needs to subscribe to an EventBridge bus in order to grab all the events that a placed into it. It then keeps track of them and you can later assert if a specific event was seen in the bus. To do so, it deploys either an SQS queue or a CloudWatch log group and subscribes it to the bus you are spying on. Spies can then use them to collect all the events from the bus and make them available to matchers.

## The `eventBridgeSpy()` helper.

This helper creates a new spy for a given event bus name. Parameters:

- `adapter`: `sqs` or `cw`. Specified how you would like the spy to subscribe to the bus. See [SQS vs CloudWatch](#SQS-vs-CloudWatch)
- `busName`: The bus name you are spying on.
- `config`: configuration for the Spy adapter.

## Usage

The simplest and more efficient way to use EventBridge spies is to create it at the very begining of your tests. i.e.: in a `beforeAll()` hook at the top of your file or a `describe` block.

```ts
let spy: EventBridgeSpy;

beforeAll(async () => {
  // create a spy. This will also deploy the required infrastructure, if need be.
  spy = await eventBridgeSpy({
    adapter: 'sqs',
    busName: 'my-bus',
  });
});

afterEach(() => {
  // clean up all events in memory between each test.
  spy.reset();
});

afterAll(async () => {
  // stop spying on the bus.
  await spy.stop();
});

it('should have event matching object', async () => {
  const order = {
    id: crypto.randomUUID(),
    createdAt: new Date().toISOString(),
  };

  await client.send(
    new PutEventsCommand({
      Entries: [
        {
          EventBusName: 'default',
          DetailType: 'orderCreated',
          Source: 'sls-jest',
          Detail: JSON.stringify(order),
        },
      ],
    }),
  );

  await expect(spy).toHaveEventMatchingObject({
    'detail-type': 'orderCreated',
    detail: {
      id: order.id,
    },
  });
});
```

## Matchers

## SQS vs CloudWatch

## Recommendations

In practice, because of the asynchronous nature of EventBridge, there is no way to control how events will be collected. For example, there is a chance that events generated by a previous test (`it`) could be delayed and might interfere with the following test. Here are some recommendations that can help mitigate this problem.

**Always use random ids and assert on them**

By using random ids and matching them in your test, you are avoiding false positive and false negative results.
For example, here is a good example of a bad test:

```ts
it('should see an orderCreated event - use case 1', async () => {
  // test case 1
  await createOrder(...);
  await expect(spy).toHaveEventMatchingObject({
    'detail-type': 'orderCreated',
  });
});

it('should see an orderCreated event - use case 1', async () => {
  // test case 2
  await createOrder(...);
  await expect(spy).toHaveEventMatchingObject({
    'detail-type': 'orderCreated',
  });
});
```

Matching only against the `detail-type` is not specific enough. The second test might see the event from the previous test one and return successfully, when in fact no event was placed.

better:

```ts
it('should see an orderCreated event - use case 1', async () => {
  // test case 1
  const randomId = crypto.randomUUID();
  await createOrder({
    id: randomId,
    //...
  });
  await expect(spy).toHaveEventMatchingObject({
    'detail-type': 'orderCreated',
    details: {
      id: randomId,
    },
  });
});

it('should see an orderCreated event - use case 1', async () => {
  // test case 2
  const randomId = crypto.randomUUID();
  await createOrder({
    id: randomId,
    //...
  });
  await expect(spy).toHaveEventMatchingObject({
    'detail-type': 'orderCreated',
    details: {
      id: randomId,
    },
  });
});
```

In this second example, generating a random id guarantees that the assertion will fail if the ids don't match.

**Use adequate timeouts**

When matchers try to see if an event is seen, they wait up to a certain amount of time until the even is either asserted, or the matchers gives up and considers the assertion fails. Using too short timeouts can cause false positives as the eent you are looking for might arrive a little later. On the other hand, using too long timeouts can artifitially slow down your test suite. Playing with different timeouts can reduce this inconvenient.

Example

If you expect an event NOT to be seen, it will force the matcher to wait until the specified timeout, after which it will consider that the event was indeed not seen. Setting a low timeout could give false positive results (e.g.: if the event arrives after the timeout), but setting it too high would slow down your tests since the matcher will wait longer.

```ts
await expect(spy).not.toHaveEventMatchingObject(
  {
    'detail-type': 'orderCreated',
    detail: {
      id: order.id,
    },
  },
  {
    timeout: 15000, // 15 seconds timeout
  },
);
```
